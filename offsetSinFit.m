function [calibrationFactors, fitRSquare, fitConfInt] = offsetSinFit(x, y, initParams, weightFit)
%OFFSETSINFIT(X,Y)
%  a*sin(bx + c) + d fit
%
%  Data for 'untitled fit 1' fit:
%      X Input : x
%      Y Output: y
%      Estimate of fit parameters: initParams
%  Output:
%      fitresult : a fit object representing the fit.
%      gof : structure with goodness-of fit info.
%
%  See also FIT, CFIT, SFIT.

%  Auto-generated by MATLAB on 04-Jun-2014 09:50:41


%% Fit: 'Offset Sine Fit'.
%[xData, yData] = prepareCurveData( x, y );
xData = squeeze(x);
yData = squeeze(y);

% Set up fittype and options.
ft = fittype( 'a*sin(b*x + c) + d', 'independent', 'x', 'dependent', 'y' );
opts = fitoptions( 'Method', 'NonlinearLeastSquares' );
opts.Display = 'Off';
opts.StartPoint = initParams;
opts.Lower = [-1.75*abs(initParams(1)) 0.8*initParams(2) 0 -5*abs(initParams(4))];
opts.Upper = [1.75*abs(initParams(1)) 1.2*initParams(2) 2*pi 5*abs(initParams(4))];

if nargin>3
    opts.Weights = weightFit;
end

% Fit model to data.
[fitresult, gof] = fit( xData, yData, ft, opts );

% fudge to fix bug where fit didn't work sometimes when amplitude of sine fit should have been negative
% if (gof.rsquare < 0.99) 
%     initParams(1) = -initParams(1); % try negative amplitude
%     opts.StartPoint = initParams;
%     [tmpFitResult, tmpGoF] = fit( xData, yData, ft, opts );
%     
%     if (tmpGoF.rsquare > gof.rsquare)
%         % now create a result with positive amplitude but shifted by pi,
%         % this should be exactly the same function but fit again just to be
%         % safe.
%         % this basically just shifts discontinuities in a (the amplitude we
%         % care about) in to discontinuities in c instead (a phase
%         % shift we don't really care about).
%         initParams(1) = -tmpFitResult.a;
%         initParams(2) = tmpFitResult.b;
%         initParams(3) = tmpFitResult.c - pi;
%         initParams(4) = tmpFitResult.d;
%         opts.Lower = [1.3*abs(initParams(1)) 0.5*initParams(2) -2*pi -5*abs(initParams(4))];
%         opts.Upper = [0.7*abs(initParams(1)) 1.5*initParams(2)  2*pi  5*abs(initParams(4))];
% 
%         opts.StartPoint = initParams;
%         [fitresult, gof] = fit( xData, yData, ft, opts );
%         
%     end
% end

calibrationFactors = NaN(1,4);
calibrationFactors(1) = fitresult.a;
calibrationFactors(2) = fitresult.b;
calibrationFactors(3) = fitresult.c;
calibrationFactors(4) = fitresult.d;

fitConfInt = confint(fitresult);
fitConfInt = calibrationFactors-fitConfInt(1,:);

fitRSquare = gof.rsquare;
% fudge to fix bug where fit didn't work sometimes when amplitude of sine fit should have been negative
if (fitresult.a < 0)
    
        % now create a result with positive amplitude but shifted by pi,
        % this should be exactly the same function but fit again just to be
        % safe.
        % this basically just shifts discontinuities in a (the amplitude we
        % care about) in to discontinuities in c instead (a phase
        % shift we don't really care about).

        calibrationFactors(1) = -calibrationFactors(1);
        calibrationFactors(3) = calibrationFactors(3)-pi;
        
%         fitresult.a = -fitresult.a;
%         fitresult.c = fitresult.c - pi;
        
%         initParams(1) = -fitresult.a;
%         initParams(2) = fitresult.b;
%         initParams(3) = fitresult.c - pi;
%         initParams(4) = fitresult.d;
        
%         opts.StartPoint = initParams;
%         opts.Lower = [0.9*abs(initParams(1)) 0.9*initParams(2) -2*pi -1.1*abs(initParams(4))];
%         opts.Upper = [1.1*abs(initParams(1)) 1.1*initParams(2)  2*pi  1.1*abs(initParams(4))];
% 
%         [fitresult, gof] = fit( xData, yData, ft, opts );
end
    

% Plot fit with data.
% figure( 'Name', 'untitled fit 1' );
% h = plot( fitresult, xData, yData );
% legend( h, 'y vs. x', 'untitled fit 1', 'Location', 'NorthEast' );
% % Label axes
% xlabel( 'x' );
% ylabel( 'y' );
% grid on


